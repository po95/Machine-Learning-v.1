# -*- coding: utf-8 -*-
"""ML Fake news Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MM6wq7lQMtzHgnq1AgldnjO83ksfJLLW

#<center> Fake news Detection </center>
"""

#libraries
import numpy as np
import pandas as pd
from numpy import genfromtxt
#from google.colab import files

#text data config : nltk library
# from nltk.stem import snowball 
# from nltk.stem import PorterStemmer
# from nltk.tokenize import word_tokenize, sent_tokenize

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
import itertools

#to_plot_graph 
import matplotlib.pyplot as plt

#Dataset
#uploaded = files.upload()
data = pd.read_csv("fakenews.csv")
#print(data)
text = data.text
label = data.label
x_train, x_test, y_train, y_test = train_test_split(text,label,test_size=0.30)

#feature extraction

countvectorizer = CountVectorizer()
count_train = countvectorizer.fit_transform(x_train)
count_test = countvectorizer.transform(x_test)

tfidf_vector = TfidfVectorizer(max_df=0.7)
tfidf_train = tfidf_vector.fit_transform(x_train)
tfidf_test = tfidf_vector.transform(x_test)

feature_arr = tfidf_vector.get_feature_names()

tfidf_df = pd.DataFrame(tfidf_train.A, columns  = tfidf_vector.get_feature_names())

#print(tfidf_df)

#Plotting graph
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
   
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('')
#         print('Confusion matrix, with little normalization')

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.rcParams['figure.figsize'] = [10, 10]
    plt.show()

#classifier
#naive bayes
from sklearn.naive_bayes import GaussianNB
clf_nav = GaussianNB()
clf_nav.fit(tfidf_train.todense(),y_train)
print(clf_nav.predict(tfidf_test[1].todense()))
print(type(y_test))
test_score = accuracy_score(clf_nav.predict(tfidf_test.todense()),y_test)
print(test_score*100)